<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>本站镜像站启用</title>
    <url>/20250408/%E6%9C%AC%E7%AB%99%E9%95%9C%E5%83%8F%E7%AB%99%E6%AD%A3%E5%BC%8F%E5%90%AF%E7%94%A8/</url>
    <content><![CDATA[<p>本站主站： <a href="https://zxclf.github.io/">https://zxclf.github.io/</a> (使用Github搭建)</p>
<p>本站镜像站： <a href="https://zxclf-github-io.pages.dev/">https://zxclf-github-io.pages.dev/</a> (使用Cloudflare搭建)</p>
<p>本站开源地址：<a href="https://github.com/ZXCLF/ZXCLF.github.io">https://github.com/ZXCLF/ZXCLF.github.io</a></p>
]]></content>
  </entry>
  <entry>
    <title>包管理器SAT求解与fsync机制技术解析</title>
    <url>/20260117/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8SAT%E6%B1%82%E8%A7%A3%E4%B8%8Efsync%E6%9C%BA%E5%88%B6%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="包管理器SAT求解与fsync机制技术解析"><a href="#包管理器SAT求解与fsync机制技术解析" class="headerlink" title="包管理器SAT求解与fsync机制技术解析"></a>包管理器SAT求解与fsync机制技术解析</h1><pre class="mermaid">graph TD
    A[包管理操作开始] --> B[SAT求解器分析依赖关系]
    B --> C[生成事务方案]
    C --> D[下载/验证软件包]
    D --> E[文件系统操作]
    E --> F{是否调用fsync?}
    F -->|是| G[强制刷盘保证一致性]
    F -->|否| H[依赖OS缓存机制]
    G --> I[操作完成-高一致性]
    H --> J[操作完成-高性能]</pre>

<span id="more"></span>

<h2 id="详细机制分解"><a href="#详细机制分解" class="headerlink" title="详细机制分解"></a>详细机制分解</h2><h3 id="SAT求解器在包管理器中的作用"><a href="#SAT求解器在包管理器中的作用" class="headerlink" title="SAT求解器在包管理器中的作用"></a>SAT求解器在包管理器中的作用</h3><pre class="mermaid">graph LR
    A[用户请求] --> B[包集合与约束条件]
    B --> C[SAT求解器引擎]
    C --> D[CNF转换]
    D --> E[DPLL/CDCL算法]
    E --> F{存在解?}
    F -->|是| G[生成安装/升级计划]
    F -->|否| H[报告依赖冲突]
    G --> I[验证解决方案]
    H --> J[建议解决方案]</pre>

<h2 id="包管理器分析"><a href="#包管理器分析" class="headerlink" title="包管理器分析"></a>包管理器分析</h2><h3 id="APT-Debian-实现分析"><a href="#APT-Debian-实现分析" class="headerlink" title="APT (Debian) 实现分析"></a>APT (Debian) 实现分析</h3><pre class="mermaid">graph TB
    A[APT架构] --> B[前端: apt/apt-get]
    A --> C[解析器: libapt]
    A --> D[后端: dpkg]
    
    B --> E[用户接口层]
    C --> F[依赖解析引擎]
    D --> G[包安装执行]
    
    F --> H[基于Debian控制文件]
    F --> I[简单的贪婪算法]
    F --> J[非完全SAT求解器]
    
    G --> K[使用dpkg数据库]
    G --> L[fsync策略: 部分使用]
    
    M[特点] --> N[稳定优先于最优解]
    M --> O[依赖预依赖/中断点]
    M --> P[历史兼容性强]</pre>

<ul>
<li><strong>APT关键特性：</strong><ul>
<li><strong>依赖解析</strong>：其解析引擎基于Debian那套历史悠久的控制文件格式，本质上采用的是一种在长期演化中形成的、旨在优先保证系统不崩溃的启发式贪婪算法，而非追求数学完备性的SAT求解器。</li>
<li><strong>fsync使用</strong>：dpkg在更新自身数据库这类关键路径上会调用fsync，但对于大量普通文件的写入则选择依赖内核的缓存机制，这种混合策略是在数十年的服务器与桌面部署实践中形成的折中方案。</li>
<li><strong>事务模型</strong>：它并不提供原子事务，而是通过一套名为“dpkg中断点”的机制，在安装过程意外中止时能够在下一次操作时恢复到某个一致的状态，这好比在长途徒步中设置的多个应急营地。</li>
</ul>
</li>
</ul>
<h3 id="DNF-RPM-Fedora-RHEL-实现分析"><a href="#DNF-RPM-Fedora-RHEL-实现分析" class="headerlink" title="DNF&#x2F;RPM (Fedora&#x2F;RHEL) 实现分析"></a>DNF&#x2F;RPM (Fedora&#x2F;RHEL) 实现分析</h3><pre class="mermaid">graph LR
    A[DNF架构] --> B[前端: dnf命令]
    A --> C[依赖解析: hawkey/libsolv]
    A --> D[后端: RPM]
    
    subgraph "SAT求解核心"
        C1[libsolv库] --> C2[完整的SAT求解器]
        C2 --> C3[支持复杂布尔约束]
        C3 --> C4[多仓库优化]
    end
    
    subgraph "RPM事务"
        D1[RPM数据库] --> D2[使用Berkeley DB]
        D2 --> D3[事务性更新]
        D3 --> D4[预写日志WAL]
    end
    
    subgraph "fsync策略"
        E1[关键操作] --> E2[RPM数据库更新fsync]
        E2 --> E3[配置文件可选]
        E3 --> E4[性能与可靠性平衡]
    end</pre>

<ul>
<li><strong>DNF关键特性：</strong><ul>
<li><strong>SAT求解器</strong>：其核心依赖的libsolv库是一个为包管理领域专门优化过的高性能、完备SAT求解器实现，能够精确处理包之间复杂的布尔约束关系。</li>
<li><strong>事务性</strong>：底层的RPM包数据库使用Berkeley DB，从而提供了一种基础的、支持回滚的事务性更新能力。</li>
<li><strong>fsync策略</strong>：对于RPM数据库的所有更新操作都强制执行刷盘，以确保元数据的一致性，但对于用户配置文件等内容的写入，则将选择权交给了系统管理员进行配置。</li>
</ul>
</li>
</ul>
<h3 id="Zypper-openSUSE-实现分析"><a href="#Zypper-openSUSE-实现分析" class="headerlink" title="Zypper (openSUSE) 实现分析"></a>Zypper (openSUSE) 实现分析</h3><pre class="mermaid">graph TD
    A[Zypper] --> B[基于libsolv]
    A --> C[SUSE特定扩展]
    
    B --> D[SAT求解能力]
    D --> E[解决依赖冲突]
    D --> F[多版本支持]
    
    C --> G[Delta RPM支持]
    C --> H[安装源优先级]
    C --> I[补丁管理集成]
    
    subgraph "文件系统策略"
        J[RPM后端] --> K[数据库fsync]
        J --> L[文件写入异步]
        M[zypper特定] --> N[下载缓存管理]
        M --> O[回滚机制]
    end
    
    P[独特特性] --> Q[强事务支持]
    P --> R[快照集成Btrfs]
    P --> S[严格依赖检查]</pre>

<h3 id="AUR-Helpers-yay-paru-分析"><a href="#AUR-Helpers-yay-paru-分析" class="headerlink" title="AUR Helpers (yay&#x2F;paru) 分析"></a>AUR Helpers (yay&#x2F;paru) 分析</h3><pre class="mermaid">graph TB
    A[AUR Helper架构] --> B[前端: yay/paru]
    A --> C[后端: pacman]
    A --> D[AUR接口]
    
    B --> E[用户交互增强]
    E --> F[交互式PKGBUILD]
    E --> G[并行下载]
    E --> H[彩色输出]
    
    D --> I[查询AUR]
    D --> J[下载PKGBUILD]
    D --> K[本地编译]
    
    subgraph "与pacman关系"
        L[包装器模式] --> M[调用pacman安装]
        M --> N[继承pacman特性]
        N --> O[无独立fsync]
        N --> P[无独立SAT求解]
    end
    
    subgraph "安全性考虑"
        Q[用户构建] --> R[潜在安全风险]
        S[非官方源] --> T[信任级别不同]
        U[安全性] --> V[需要用户审核]
    end</pre>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th>包管理器</th>
<th>SAT求解器</th>
<th>fsync策略</th>
<th>事务支持</th>
<th>设计理念</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>APT</strong></td>
<td>启发式算法</td>
<td>部分使用</td>
<td>有限恢复</td>
<td>稳定至上</td>
<td>Debian&#x2F;Ubuntu服务器</td>
</tr>
<tr>
<td><strong>DNF</strong></td>
<td>libsolv (完整SAT)</td>
<td>数据库强制</td>
<td>RPM事务</td>
<td>企业级可靠</td>
<td>RHEL&#x2F;Fedora企业</td>
</tr>
<tr>
<td><strong>Zypper</strong></td>
<td>libsolv扩展</td>
<td>数据库强制</td>
<td>强事务</td>
<td>SUSE企业特性</td>
<td>openSUSE&#x2F;SLE</td>
</tr>
<tr>
<td><strong>pacman</strong></td>
<td>简单解析</td>
<td>不使用</td>
<td>无</td>
<td>简单快速</td>
<td>Arch桌面</td>
</tr>
<tr>
<td><strong>yay&#x2F;paru</strong></td>
<td>依赖pacman</td>
<td>同pacman</td>
<td>同pacman</td>
<td>AUR便利性</td>
<td>Arch用户构建</td>
</tr>
<tr>
<td><strong>Nix</strong></td>
<td>自定义求解器</td>
<td><strong>强制使用</strong></td>
<td>原子事务</td>
<td>纯函数式</td>
<td>开发&#x2F;可重复</td>
</tr>
<tr>
<td><strong>Portage</strong></td>
<td>增强解析</td>
<td>使用sync()</td>
<td>阶段提交</td>
<td>源码灵活性</td>
<td>Gentoo定制</td>
</tr>
<tr>
<td><strong>apk</strong></td>
<td>简单解析</td>
<td><strong>强制使用</strong></td>
<td>原子操作</td>
<td>小型可靠</td>
<td>Alpine&#x2F;容器</td>
</tr>
<tr>
<td><strong>xbps</strong></td>
<td>布尔解析</td>
<td>可选</td>
<td>有限</td>
<td>平衡设计</td>
<td>Void通用</td>
</tr>
<tr>
<td><strong>Flatpak</strong></td>
<td>OSTree层</td>
<td>应用级别</td>
<td>引用计数</td>
<td>沙箱部署</td>
<td>跨发行版应用</td>
</tr>
</tbody></table>
<h3 id="fsync策略对比"><a href="#fsync策略对比" class="headerlink" title="fsync策略对比"></a>fsync策略对比</h3><pre class="mermaid">graph TB
    subgraph "强制或广泛使用fsync"
        A1[Nix/Guix] --> A2[完全原子性<br>崩溃安全]
        B1[apk Alpine] --> B2[嵌入式导向<br>数据完整性优先]
        C1[Zypper/DNF] --> C2[企业级需求<br>数据库一致性]
    end
    
    subgraph "选择性使用fsync"
        D1[APT/dpkg] --> D2[关键元数据fsync<br>其他延迟写入]
        E1[Portage] --> E2[重要阶段sync<br>编译过程异步]
        F1[xbps] --> F2[可配置策略<br>用户决定]
    end
    
    subgraph "最小化fsync"
        G1[pacman] --> G2[依赖文件系统<br>Ext4/journaling]
        H1[Slackpkg] --> H2[极简设计<br>用户负责]
        I1[Flatpak] --> I2[用户空间操作<br>系统影响小]
    end
    
    subgraph "AUR Helpers"
        J1[yay/paru] --> J2[完全依赖pacman<br>无额外fsync]
    end</pre>

<h3 id="SAT求解器"><a href="#SAT求解器" class="headerlink" title="SAT求解器"></a>SAT求解器</h3><pre class="mermaid">graph TD
    A[SAT求解能力层级] --> B[第一层: 完整SAT求解器]
    A --> C[第二层: 高级启发式算法]
    A --> D[第三层: 简单依赖解析]
    A --> E[第四层: 无依赖解析]
    
    B --> B1[libsolv-based]
    B1 --> B2[DNF/RPM]
    B1 --> B3[Zypper]
    B2 --> B4[复杂布尔逻辑]
    B3 --> B5[多仓库优化]
    
    C --> C1[APT/aptitude]
    C1 --> C2[稳定解优先]
    C2 --> C3[非最优但实用]
    
    D --> D1[pacman]
    D1 --> D2[线性依赖检查]
    D --> D3[apk Alpine]
    D3 --> D4[简单约束求解]
    
    E --> E1[Slackpkg]
    E1 --> E2[按列表顺序]
    E --> E3[AUR Helpers]
    E3 --> E4[传递到pacman]
    
    F[特殊类别] --> G[Nix/Guix]
    G --> H[函数式依赖图]
    H --> I[非传统SAT]</pre>

<h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><h3 id="APT的依赖解析机制"><a href="#APT的依赖解析机制" class="headerlink" title="APT的依赖解析机制"></a>APT的依赖解析机制</h3><pre class="mermaid">graph LR
    A[APT依赖解析流程] --> B[读取Packages文件]
    B --> C[构建依赖图]
    
    subgraph "解析算法"
        C1[基于Debian策略] --> C2[偏好已安装版本]
        C2 --> C3[避免破坏现有包]
        C3 --> C4[使用推荐而非依赖]
        C4 --> C5[处理Pre-Depends]
    end
    
    C --> D[生成安装方案]
    D --> E{方案可行?}
    E -->|是| F[执行安装]
    E -->|否| G[尝试放松约束]
    G --> H[移除冲突包]
    H --> I[用户确认]
    
    J[非SAT特性] --> K[不保证最优解]
    K --> L[但保证系统稳定]
    L --> M[历史兼容性保持]</pre>

<h3 id="DNF-libsolv-SAT求解过程"><a href="#DNF-libsolv-SAT求解过程" class="headerlink" title="DNF&#x2F;libsolv SAT求解过程"></a>DNF&#x2F;libsolv SAT求解过程</h3><pre class="mermaid">graph TD
    A[libsolv工作流程] --> B[加载仓库元数据]
    B --> C[构建求解问题]
    
    subgraph "问题表示"
        C1[包表示为变量]
        C2[版本约束为子句]
        C3[依赖关系为蕴含]
        C4[冲突为否定子句]
    end
    
    C --> D[应用SAT算法]
    
    subgraph "求解阶段"
        D1[决策: 选择包版本]
        D2[布尔约束传播]
        D3[冲突分析与学习]
        D4[非时序回溯]
        D5[启发式变量选择]
    end
    
    D --> E{找到解?}
    E -->|是| F[优化解决方案]
    F --> F1[最小化变更]
    F1 --> F2[偏好新版本]
    F2 --> F3[仓库优先级]
    
    E -->|否| G[放松约束]
    G --> H[移除可选依赖]
    H --> I[允许旧版本]
    I --> J[生成替代方案]</pre>



<h2 id="适用使用场景"><a href="#适用使用场景" class="headerlink" title="适用使用场景"></a>适用使用场景</h2><pre class="mermaid">graph TD
    A[选择标准] --> B{主要需求?}
    
    B -->|企业服务器| C[DNF/Zypper]
    C --> C1[强事务支持]
    C1 --> C2[企业维护]
    
    B -->|稳定性优先| D[APT]
    D --> D1[保守更新]
    D1 --> D2[广泛测试]
    
    B -->|桌面最新软件| E[pacman + AUR]
    E --> E1[滚动更新]
    E1 --> E2[社区驱动]
    
    B -->|开发环境| F[Nix/Guix]
    F --> F1[可重复环境]
    F1 --> F2[多版本共存]
    
    B -->|容器最小化| G[apk Alpine]
    G --> G1[小型镜像]
    G1 --> G2[安全加固]
    
    B -->|系统定制| H[Portage]
    H --> H1[源码优化]
    H1 --> H2[完全控制]
    
    B -->|简洁稳定| I[xbps/Slackpkg]
    I --> I1[简洁设计]
    I1 --> I2[低维护]</pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不同包管理器在SAT求解能力和fsync策略上体现了各自的设计哲学和目标用户群体。<strong>企业级系统</strong>（RHEL&#x2F;SUSE）倾向于使用完整的SAT求解器和强一致性保证，而<strong>桌面系统</strong>（Arch&#x2F;Debian）更注重用户体验和性能。<strong>新兴系统</strong>（Nix&#x2F;Alpine）则在特定领域（开发&#x2F;容器）提供了创新的解决方案。</p>
]]></content>
  </entry>
  <entry>
    <title>Arch Linux 安装指南（支持Arch to go）</title>
    <url>/20250809/Arch%20Linux%20%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Arch-Linux-安装指南（支持Arch-to-go）"><a href="#Arch-Linux-安装指南（支持Arch-to-go）" class="headerlink" title="Arch Linux 安装指南（支持Arch to go）"></a>Arch Linux 安装指南（支持Arch to go）</h1><blockquote>
<p>Arch殿堂之上，历代发行版纷争百余次，是非功过未易评断，然技术史家无不承认，正是在这方终端之中，决定了多少开发者的心智归属、系统生态的流向沉浮，故而社区素有“真理之殿”的传说。</p>
<p>当年林纳斯托瓦兹首释内核源代码，开源运动如星火燎原。Debian以稳如磐石之志立下基石，红帽借企业之力拓土开疆。公元二〇〇三年，也正是在这滚动更新的浪潮前，Arch社区以KISS之道铸就极简利刃，以Wiki为盾，以AUR为弓，于纷繁发行版中夺下一片天地！</p>
<p>我不明白，为何众人总在议论 Debian 的稳如磐石，仿佛这自由世界对我们注定了曲高和寡。数年前，我从一份纯净的安装媒介踏上征途，开启了滚动发布的新章，Linux桌面的灵活精悍遂入新境。Pacman所到之处，极客欣然相迎，真可谓尽握自主，那种清晰透明、万物由我的境界，犹在眼前。短短数载之后，这里竟至于一变而成为我等理念的困守之地了么？</p>
<p>无论怎么讲，版本迭代，是滚动对固定，优势在我！</p>
</blockquote>
<h2 id="1-验证启动模式"><a href="#1-验证启动模式" class="headerlink" title="1. 验证启动模式"></a>1. 验证启动模式</h2><p>检查系统是否以 UEFI 模式启动（现代电脑基本都是UEFI启动）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure>
<p>如果能看到文件列表，说明是UEFI启动模式。</p>
<h2 id="2-建立网络连接"><a href="#2-建立网络连接" class="headerlink" title="2. 建立网络连接"></a>2. 建立网络连接</h2><p>启用网络并测试连通性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dhcpcd  <span class="comment"># 自动获取IP地址</span></span><br><span class="line">ping archlinux.org -c 3  <span class="comment"># 测试网络是否通畅</span></span><br></pre></td></tr></table></figure>

<h2 id="3-同步系统时间"><a href="#3-同步系统时间" class="headerlink" title="3. 同步系统时间"></a>3. 同步系统时间</h2><p>确保系统时间准确（防止安装过程中出现时间错误）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl set-ntp <span class="literal">true</span>  <span class="comment"># 启用网络时间同步</span></span><br><span class="line">timedatectl status  <span class="comment"># 检查时间状态</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="4-磁盘分区与格式化"><a href="#4-磁盘分区与格式化" class="headerlink" title="4. 磁盘分区与格式化"></a>4. 磁盘分区与格式化</h2><h3 id="查看存储设备"><a href="#查看存储设备" class="headerlink" title="查看存储设备"></a>查看存储设备</h3><p>先确认你的磁盘设备名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk  <span class="comment"># 列出所有存储设备</span></span><br></pre></td></tr></table></figure>

<h3 id="分区操作（重点）"><a href="#分区操作（重点）" class="headerlink" title="分区操作（重点）"></a>分区操作（重点）</h3><p>使用gdisk工具进行分区（比fdisk更适合GPT分区表）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdisk /dev/sdx      <span class="comment"># 传统SATA硬盘（x替换为a,b,c等字母）</span></span><br><span class="line">gdisk /dev/nvmexn1  <span class="comment"># NVMe固态硬盘（x替换为0,1,2等数字）</span></span><br></pre></td></tr></table></figure>

<p><strong>分区步骤详解：</strong></p>
<ol>
<li>进入gdisk后，输入<code>o</code>创建新的GPT分区表</li>
<li>创建EFI分区：<ul>
<li>输入<code>n</code>新建分区</li>
<li>分区号默认回车</li>
<li>起始扇区默认回车</li>
<li>输入<code>+512M</code>设置分区大小</li>
<li>输入<code>ef00</code>设置分区类型为EFI系统分区</li>
</ul>
</li>
<li>创建根分区：<ul>
<li>再次输入<code>n</code>新建分区</li>
<li>所有提示都按回车（使用剩余全部空间）</li>
<li>分区类型保持默认的Linux文件系统(8300)</li>
</ul>
</li>
<li>输入<code>w</code>保存并退出（所有更改将生效）</li>
</ol>
<h3 id="验证分区"><a href="#验证分区" class="headerlink" title="验证分区"></a>验证分区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l  <span class="comment"># 查看分区结果</span></span><br></pre></td></tr></table></figure>

<h3 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/nvme0n1p1  <span class="comment"># 格式化EFI分区为FAT32</span></span><br><span class="line">mkfs.ext4 /dev/nvme0n1p2      <span class="comment"># 格式化根分区为ext4</span></span><br></pre></td></tr></table></figure>

<h2 id="5-挂载文件系统"><a href="#5-挂载文件系统" class="headerlink" title="5. 挂载文件系统"></a>5. 挂载文件系统</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/nvme0n1p2 /mnt       <span class="comment"># 挂载根分区</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt/boot              <span class="comment"># 创建boot目录</span></span><br><span class="line">mount /dev/nvme0n1p1 /mnt/boot  <span class="comment"># 挂载EFI分区</span></span><br></pre></td></tr></table></figure>

<h2 id="6-配置软件源（国内用户必看）"><a href="#6-配置软件源（国内用户必看）" class="headerlink" title="6. 配置软件源（国内用户必看）"></a>6. 配置软件源（国内用户必看）</h2><p>替换为国内镜像源加速下载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>

<p>在文件最前面添加（建议使用清华或中科大源）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure>

<h2 id="7-安装基础系统"><a href="#7-安装基础系统" class="headerlink" title="7. 安装基础系统"></a>7. 安装基础系统</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacstrap /mnt base base-devel linux linux-firmware vim dhcpcd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个命令会安装最基本的系统组件，大约需要5-15分钟，取决于你的网速。</p>
</blockquote>
<h2 id="8-生成文件系统表"><a href="#8-生成文件系统表" class="headerlink" title="8. 生成文件系统表"></a>8. 生成文件系统表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure>

<h2 id="9-切换根环境"><a href="#9-切换根环境" class="headerlink" title="9. 切换根环境"></a>9. 切换根环境</h2><blockquote>
<p><code>arch-chroot</code> 是 Arch Linux 提供的工具，相比标准的 <code>chroot</code>，它会自动挂载 <code>/proc</code>、<code>/sys</code>、<code>/dev</code> 等虚拟文件系统，简化了操作。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure>

<h2 id="10-配置时区"><a href="#10-配置时区" class="headerlink" title="10. 配置时区"></a>10. 配置时区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure>

<h2 id="11-本地化设置"><a href="#11-本地化设置" class="headerlink" title="11. 本地化设置"></a>11. 本地化设置</h2><p>编辑语言配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure>

<p>取消注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line">zh_CN.UTF-8 UTF-8</span><br></pre></td></tr></table></figure>

<p>生成本地化设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale-gen</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;LANG=en_US.UTF-8&quot;</span> &gt; /etc/locale.conf</span><br></pre></td></tr></table></figure>

<h2 id="12-网络配置"><a href="#12-网络配置" class="headerlink" title="12. 网络配置"></a>12. 网络配置</h2><p>设置主机名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;myhostname&quot;</span> &gt; /etc/hostname</span><br></pre></td></tr></table></figure>

<p>编辑 hosts 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>

<p>添加内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br><span class="line">127.0.1.1   myhostname.localdomain myhostname</span><br></pre></td></tr></table></figure>

<h2 id="13-设置-root-密码"><a href="#13-设置-root-密码" class="headerlink" title="13. 设置 root 密码"></a>13. 设置 root 密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>

<h2 id="14-安装引导程序-GRUB"><a href="#14-安装引导程序-GRUB" class="headerlink" title="14. 安装引导程序 (GRUB)"></a>14. 安装引导程序 (GRUB)</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pacman -S --needed grub efibootmgr</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>

<h2 id="15-启用网络服务"><a href="#15-启用网络服务" class="headerlink" title="15. 启用网络服务"></a>15. 启用网络服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> dhcpcd</span><br></pre></td></tr></table></figure>

<h2 id="16-创建标准用户"><a href="#16-创建标准用户" class="headerlink" title="16. 创建标准用户"></a>16. 创建标准用户</h2><p>添加用户并设置密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m -G wheel -s /bin/bash username</span><br><span class="line">passwd username</span><br></pre></td></tr></table></figure>

<p>配置 sudo 权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure>

<p>取消注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%wheel ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>

<h2 id="17-启用额外软件源"><a href="#17-启用额外软件源" class="headerlink" title="17. 启用额外软件源"></a>17. 启用额外软件源</h2><p>编辑 pacman 配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.conf</span><br></pre></td></tr></table></figure>

<p>取消注释启用 multilib：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>

<p>添加 Arch Linux CN 源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure>

<p>更新并安装密钥环：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Sy</span><br><span class="line">pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure>

<h2 id="18-完成安装"><a href="#18-完成安装" class="headerlink" title="18. 完成安装"></a>18. 完成安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">umount -R /mnt</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="19-配置默认编辑器"><a href="#19-配置默认编辑器" class="headerlink" title="19. 配置默认编辑器"></a>19. 配置默认编辑器</h2><h3 id="root-账户"><a href="#root-账户" class="headerlink" title="root 账户"></a>root 账户</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> EDITOR=<span class="string">&#x27;vim&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="普通账户"><a href="#普通账户" class="headerlink" title="普通账户"></a>普通账户</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> EDITOR=<span class="string">&#x27;vim&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="20-安装-KDE-Plasma-桌面环境"><a href="#20-安装-KDE-Plasma-桌面环境" class="headerlink" title="20. 安装 KDE Plasma 桌面环境"></a>20. 安装 KDE Plasma 桌面环境</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pacman -S plasma-meta konsole dolphin plasma-x11-session <span class="comment"># plasma-meta 元软件包、konsole 终端模拟器和 dolphin 文件管理器</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> sddm</span><br></pre></td></tr></table></figure>

<h2 id="21-安装基础软件包"><a href="#21-安装基础软件包" class="headerlink" title="21. 安装基础软件包"></a>21. 安装基础软件包</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pacman -S --needed curl wget nano vim p7zip <span class="built_in">which</span> lvm2 <span class="comment">#基础包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S sof-firmware alsa-firmware alsa-ucm-conf <span class="comment"># 声音固件</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S ntfs-3g <span class="comment"># 使系统可以识别 NTFS 格式的硬盘</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S adobe-source-han-serif-cn-fonts ttf-liberation <span class="comment"># 安装开源中文字体，注意：最好不要安装wqy-zenhei wqy-microhei，字体效果很差</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra <span class="comment"># 安装谷歌开源字体及表情</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S firefox chromium <span class="comment"># 安装常用的火狐、chromium 浏览器</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S packagekit-qt6 packagekit appstream-qt appstream <span class="comment"># 确保 Discover（软件中心）可用，需重启</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S yay <span class="comment">#aur包管理器</span></span><br></pre></td></tr></table></figure>

<h2 id="22-启动显示管理器与网络工具"><a href="#22-启动显示管理器与网络工具" class="headerlink" title="22. 启动显示管理器与网络工具"></a>22. 启动显示管理器与网络工具</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start sddm</span><br><span class="line">systemctl start NetworkManager.service</span><br><span class="line">systemctl <span class="built_in">enable</span> NetworkManager.service</span><br></pre></td></tr></table></figure>

<h2 id="23-配置中文显示"><a href="#23-配置中文显示" class="headerlink" title="23. 配置中文显示"></a>23. 配置中文显示</h2><h3 id="KDE-语言设置"><a href="#KDE-语言设置" class="headerlink" title="KDE 语言设置"></a>KDE 语言设置</h3><ol>
<li>打开 <code>Region and Language</code></li>
<li>点击 <code>Language</code> 后的 <code>Modify</code></li>
<li>右下角 <code>Add More</code> 添加 <code>简体中文</code></li>
<li>将中文移至顶部</li>
</ol>
<h3 id="SDDM-锁屏界面"><a href="#SDDM-锁屏界面" class="headerlink" title="SDDM 锁屏界面"></a>SDDM 锁屏界面</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /etc/systemd/system/sddm.service.d</span><br><span class="line">vim /etc/systemd/system/sddm.service.d/EnvironmentFile.conf</span><br></pre></td></tr></table></figure>

<p>添加内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/default/locale</span><br></pre></td></tr></table></figure>

<p>编辑区域文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/default/locale</span><br></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=zh_CN.UTF-8</span><br></pre></td></tr></table></figure>

<h2 id="24-安装中文输入法"><a href="#24-安装中文输入法" class="headerlink" title="24. 安装中文输入法"></a>24. 安装中文输入法</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-material-color</span><br></pre></td></tr></table></figure>

<p>配置环境变量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/environment</span><br></pre></td></tr></table></figure>

<p>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XIM=fcitx</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>

<h2 id="26-支持Arch-to-go"><a href="#26-支持Arch-to-go" class="headerlink" title="26.支持Arch to go"></a>26.支持Arch to go</h2><p>执行官方<a href="https://github.com/ventoy/vtoyboot/releases">vtoyboot脚本</a>后执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&quot;s/PARTUUID=[0-9a-f-]*/UUID=<span class="variable">$&#123;ROOT_UUID&#125;</span>/&quot;</span> /boot/grub/grub.cfg</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /boot/EFI/BOOT/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /boot/EFI/GRUB/grubx64.efi /boot/EFI/BOOT/BOOTX64.efi</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Magisk模块刷入指南：一场Android系统的持久战</title>
    <url>/20250628/Magisk%E6%A8%A1%E5%9D%97%E5%88%B7%E5%85%A5%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>广大手机用户们，技术爱好者们：</p>
<p>​		当今世界，手机已成为我们工作、学习、生活乃至斗争的重要工具。然则，部分手机厂商筑起的高墙（锁Bootloader、系统限制、失去保修），如同旧社会的三座大山，束缚着我们充分改造设备、发挥其潜力的手脚。</p>
<p>​		Magisk，便是我们手中的“星星之火”，它扎根于系统底层（Systemless），为我们争取“最高权限”（Root），开辟了安装革命性模块（Modules）的广阔天地。然而，斗争是复杂的，敌人（指各类检测Root的银行、支付、游戏等应用）的侦察手段也在不断翻新。如何既能掌握核心力量，又能巧妙隐蔽自己，并利用先进工具（模块）克敌制胜？这便是本指南要解决的首要问题！</p>
<span id="more"></span>

<p><strong>关键选择：推荐 Magisk_Alpha！</strong></p>
<ul>
<li><strong>为何是 Alpha？</strong> 同志们！官方 Magisk 虽好，但其隐藏性在敌人日益严密的“检测扫荡”（银行App、游戏反作弊、部分支付应用）面前，渐显吃力。Magisk_Alpha（由活跃社区维护）在隐藏性上做了大量卓有成效的改进工作，其“反检测”能力更强，更能帮助我们潜伏在敌人心脏地带而不被发现！<strong>隐蔽性就是战斗力！</strong> 务必优先选用！</li>
<li><strong>警惕 Kitsune_Mask (原 Magisk Delta)！</strong> 过去它曾是一支劲旅，但<strong>现已停止维护</strong>！停更的武器，就像生了锈的刺刀，非但不能杀敌，反而可能伤己！众多同志反馈，它存在严重Bug，例如<strong>导致32位应用程序无法运行，甚至可能迫使你进行“恢复出厂设置”这种惨烈的战略撤退才能解决问题！</strong> 我们绝不能让这样的隐患留在我们的队伍里！</li>
</ul>
<h4 id="一、隐蔽战线是生命线：Shamiko模块"><a href="#一、隐蔽战线是生命线：Shamiko模块" class="headerlink" title="一、隐蔽战线是生命线：Shamiko模块"></a><strong>一、隐蔽战线是生命线：Shamiko模块</strong></h4><blockquote>
<p>敌进我退，敌驻我扰，敌疲我打，敌退我追</p>
</blockquote>
<p>在Root的战场上，面对强大的、日益精密的Root检测（如银行APP、部分游戏、公司MDM软件），一味蛮干（直接暴露Root）是要吃大亏的！<strong>Shamiko模块，就是执行“敌后隐蔽工作”的精锐力量。</strong></p>
<ul>
<li><strong>核心任务：</strong> Shamiko不直接“消灭”检测（如Magisk Hide或早期DenyList），而是巧妙地“融入群众”（系统环境），让检测者“视而不见”。<strong>强烈推荐使用它的白名单模式。</strong></li>
<li><strong>工作方法（白名单模式）：</strong><ol>
<li>在Magisk设置中启用<strong>Zygisk</strong>（这是基础，后面详谈）。</li>
<li><strong>刷入Shamiko模块。</strong> Shamiko会以更底层、更隐蔽的方式对应用进行“伪装”，使其无法探测到Zygisk和Root的存在。</li>
</ol>
</li>
<li><strong>重要意义：</strong> 正确配置Shamiko，就如同给我们的Root行动披上了“隐身衣”，是保障金融安全、游戏畅玩、工作APP正常使用的<strong>关键一招</strong>。<strong>忽视隐蔽工作，等于主动向敌人暴露目标！</strong></li>
</ul>
<h4 id="二、灵活机动的战略战术：LSPosed框架"><a href="#二、灵活机动的战略战术：LSPosed框架" class="headerlink" title="二、灵活机动的战略战术：LSPosed框架"></a><strong>二、灵活机动的战略战术</strong>：LSPosed框架</h4><blockquote>
<p>以子之矛，陷子之盾</p>
</blockquote>
<p>Magisk给了我们根据地（Root），但要在应用层面进行更精细、更灵活的改造，就需要 <strong>LSPosed框架</strong>。它是新一代的Xposed实现，依托于Zygisk，<strong>运行效率更高，兼容性更好，模块管理更清晰。</strong></p>
<ul>
<li><strong>战略地位：</strong> LSPosed本身是一个Magisk模块。刷入它，就相当于建立了一个强大的“前线指挥部”，可以调度和指挥各种功能模块（Modules）对单个或特定应用进行“定点改造”。</li>
<li><strong>重要作战单元（模块举例）：</strong><ul>
<li><strong>隐藏应用列表模块（Hide-My-Applis）：</strong> 此乃配合Shamiko作战的“反间谍利器”。它能阻止APP检测你手机上安装了哪些应用（尤其是一些敏感或破解工具），进一步切断敌人情报来源。</li>
<li><strong>New Hook Vip等模块（仅供学习研究！）：</strong> 这类模块如同缴获的“特殊装备”，可能能解锁某些应用的特定功能（如去广告、会员权限）。<strong>务必深刻认识：</strong> 此类行为涉及版权和法律风险，如同在敌占区使用缴获武器，<strong>必须慎之又慎！</strong> 本指南<strong>仅提供技术可能性探讨，强调其学习研究价值，坚决反对用于非法目的和侵害他人合法权益。</strong> “武器”本身无罪，关键在于使用者的目的和是否符合最广大人民群众的根本利益（法律与道德）。</li>
</ul>
</li>
<li><strong>运作原理：</strong> LSPosed模块通过Hook（钩子）应用进程，在特定函数执行前后注入自己的代码，从而改变应用的行为。这种“嵌入作战”方式，使得功能修改更加精准和动态。</li>
</ul>
<h4 id="三、革命的命脉：Zygisk"><a href="#三、革命的命脉：Zygisk" class="headerlink" title="三、革命的命脉：Zygisk"></a><strong>三、革命的命脉</strong>：Zygisk</h4><blockquote>
<p>兵马未动，粮草先行。</p>
</blockquote>
<pre class="mermaid">graph LR
A[Zygote进程] --> B[Zygisk注入]
B --> C[模块寄生系统核心]
C --> D[Shamiko生效]
C --> E[LSPosed框架激活]
D -.-> F[Root隐藏]
E -.-> G[Hook系统级功能]</pre>

<p><strong>Zygisk (Zygote注入) 是Magisk现代体系的核心引擎和生命线！</strong></p>
<ul>
<li><strong>重要推荐：使用 Zygisk_Next！</strong> 同志们！原版Zygisk固然可用，但 <strong>Zygisk_Next</strong> 是社区在原版基础上的重大改进！它在<strong>稳定性、兼容性、特别是隐藏性（反检测）上更进一步！</strong> 它更有效地对抗着各种针对Zygisk的检测手段。<strong>“工欲善其事，必先利其器”，Zygisk_Next 就是我们更锋利的渗透匕首！</strong></li>
<li><strong>核心作用与原理：</strong><ul>
<li>Android系统启动应用时，都派生自一个叫<code>Zygote</code>的母进程。</li>
<li><strong>Zygisk</strong> 的核心功能，就是将自己（Magisk的核心组件）<strong>注入到<code>Zygote</code>进程中</strong>。这样一来，<strong>所有</strong>从Zygote孵化的应用程序进程，<strong>天生就继承了Magisk的环境和功能</strong>（如Root权限管理、ROOT隐藏（Shamiko）、以及最重要的——加载LSPosed等需要注入到应用进程的框架和模块）。</li>
</ul>
</li>
<li><strong>不开启Zygisk的严重后果（如同切断补给线）：</strong><ol>
<li><strong>LSPosed框架及其所有模块瘫痪：</strong> LSPosed需要注入应用进程才能工作，而Zygisk是完成这种注入的关键桥梁。关闭Zygisk，LSPosed就失去了“兵力投送”的能力，其框架本身和所有模块都将<strong>完全无法加载和工作</strong>！其他依赖进程注入的模块（如部分字体修改、深度系统优化模块）同样会失效。</li>
<li><strong>部分现代Magisk模块功能受限：</strong> 许多新模块都设计为需要Zygisk环境才能发挥全部效力。</li>
</ol>
</li>
<li><strong>结论：</strong> <strong>Zygisk是Magisk强大功能（特别是Root隐藏和LSPosed生态）得以实现的基石。关闭Zygisk，等于自废武功，使大部分高级模块陷入瘫痪！非必要，切勿关闭！</strong></li>
</ul>
<h4 id="四、警惕糖衣炮弹：防格机模块"><a href="#四、警惕糖衣炮弹：防格机模块" class="headerlink" title="四、警惕糖衣炮弹：防格机模块"></a><strong>四、警惕糖衣炮弹：防格机模块</strong></h4><blockquote>
<p>革命队伍要纯洁，模块仓库有风险！</p>
</blockquote>
<p>如同要警惕混入革命队伍的敌人，<strong>刷入来源不明、未经充分验证的模块是极其危险的！</strong></p>
<ul>
<li><strong>“格机模块”的危害：</strong> 这类恶意模块如同“特洛伊木马”，一旦刷入，可能在启动时执行破坏性脚本，导致：<ul>
<li><strong>系统关键文件被删除或篡改。</strong></li>
<li><strong>无限重启，手机变“砖”。</strong></li>
<li><strong>数据被清空（Factory Reset &#x2F; Format Data）。</strong></li>
</ul>
</li>
<li><strong>防御策略（肃反手段）：</strong><ol>
<li><strong>提高警惕，擦亮眼睛：</strong> 绝不轻信论坛、非官方渠道的所谓“神奇”、“一键破解”模块，尤其警惕要求刷入后格式化Data分区的模块。</li>
<li><strong>依靠群众，调查研究：</strong> 刷入任何模块前，务必查阅<strong>可靠社区</strong>（如XDA, 酷安相关板块）的评价反馈，了解其<strong>具体功能、风险、兼容性</strong>。</li>
<li><strong>隔离审查（沙盒测试）：</strong> 如果条件允许，先在备用机或模拟器上测试。</li>
<li><strong>备份！备份！再备份！</strong> 刷机前通过TWRP等Recovery完整备份系统（Boot, System, Data, Vendor等关键分区），这是最后的防线！</li>
</ol>
</li>
</ul>
<h4 id="五、最后的堡垒：刷入救砖模块"><a href="#五、最后的堡垒：刷入救砖模块" class="headerlink" title="五、最后的堡垒：刷入救砖模块"></a>五、最后的堡垒：刷入救砖模块</h4><blockquote>
<p>凡事预则立，不预则废。</p>
</blockquote>
<p>在复杂的刷机斗争中，难免遭遇挫折（如模块冲突导致无法开机）。<strong>预先部署“救砖模块”，就是保留革命的火种，确保有生力量。</strong></p>
<ul>
<li><strong>推荐利器：神仙自动救砖模块：</strong><ul>
<li><strong>工作原理：</strong> 此模块如同潜伏在系统深处的“应急响应小组”。</li>
<li><strong>触发机制：</strong><ul>
<li><strong>卡开机动画循环：</strong> 如果设备连续重启（例如达到3次）仍卡在开机Logo处，模块会自动触发救援。</li>
<li><strong>卡第二屏（如厂商Logo&#x2F;“Powered by Android”）超时：</strong> 如果在此界面停留超过预设时间（如90秒），模块也会启动。</li>
</ul>
</li>
<li><strong>救援行动：</strong><ol>
<li><strong>自动禁用所有Magisk模块：</strong> 这是解决因模块冲突导致无法开机的<strong>最有效手段</strong>。</li>
<li><strong>自动解冻被冻结的应用：</strong> 解决因误冻结关键系统应用（如桌面Launcher、系统UI）导致的黑屏&#x2F;无法进入系统问题。</li>
</ol>
</li>
<li><strong>战略意义：</strong> 刷入此类模块，就如同在后方建立了安全的“根据地”和“野战医院”。当前线（系统启动）遭遇重大挫折（无法开机）时，它能自动实施“战场急救”，<strong>极大提高设备从软件故障中“自救”成功的机会</strong>，避免需要连接电脑使用复杂命令（Fastboot&#x2F;ADB）或重刷系统的麻烦（保住Data数据尤为重要！）。</li>
</ul>
</li>
<li><strong>部署要求：</strong> <strong>务必在系统还能正常启动时刷入！</strong> 变砖后再想刷就晚了！将此模块视为Magisk环境的“基本险”。</li>
</ul>
<hr>
<h4 id="总结与号召"><a href="#总结与号召" class="headerlink" title="总结与号召"></a><strong>总结与号召</strong></h4><blockquote>
<p>同志们，刷机有风险，探索需谨慎，但掌握正确的方法和武器，就能化险为夷，让手机真正为我们所用！</p>
</blockquote>
<ol>
<li><strong>隐蔽是前提：</strong> Shamiko + 隐藏应用列表 是生存之道。</li>
<li><strong>框架是平台：</strong> LSPosed 是应用级改造的强大武器库，<strong>但务必合法合规使用！</strong></li>
<li><strong>Zygisk是根基：</strong> 务必开启，它是现代Magisk模块生态的命脉，关闭则万事休矣！</li>
<li><strong>安全是底线：</strong> 严防死守“格机模块”，来源不明绝不刷入！</li>
<li><strong>备份是后路：</strong> TWRP等Recovery备份是终极保险。</li>
<li><strong>救砖是保障：</strong> <strong>立即行动！</strong> 现在就刷入“神仙自动救砖”或类似可靠救砖模块，建立你的最后防线！</li>
</ol>
<p>让我们发扬“自力更生，艰苦奋斗”的精神，在Android系统改造的实践中，“从战争中学习战争”，不断掌握新知识，解决新问题！务必牢记：“战略上藐视敌人（技术困难），战术上重视敌人（每一个操作步骤）”。</p>
<p><strong>让我们团结起来，争取更大的刷机自由！</strong></p>
]]></content>
      <tags>
        <tag>Root</tag>
      </tags>
  </entry>
  <entry>
    <title>演讲稿</title>
    <url>/20250618/%E6%BC%94%E8%AE%B2%E7%A8%BF/</url>
    <content><![CDATA[<h3 id="在线预览"><a href="#在线预览" class="headerlink" title="在线预览"></a>在线预览</h3><p>尊敬的老师、亲爱的同学们：</p>
<p>今天，我怀着无比崇敬的心情，向大家讲述一位用代码编织强国梦想、用算力托举民族脊梁的科学家——中国工程院院士郑纬民教授！</p>
<p>他，是<strong>算力疆域的拓荒者</strong>。从奔跑在宁波石子路上的少年，到执掌清华计算机系统结构的巨匠，郑纬民院士用半个世纪的坚守，凿穿了存储技术的“冻土层”！他带领团队攻克<strong>存储系统的三大世界级难题</strong>，研制出中国首个自主知识产权的<strong>高可扩展海量存储网络系统TH-MSNS</strong>。其独创的“<strong>社区共享架构</strong>”，如同在数据的星空间架起虹桥，让“存储一份、全网共享”的云时代提前降临神州！</p>
<p>他，是<strong>超算巅峰的登顶人</strong>。2016年，戈登·贝尔奖——这座全球超算领域的“奥林匹克圣火”——首次被中国点燃！郑纬民团队在“神威·太湖之光”上运行<strong>高可扩展非线性地震模拟工具</strong>，以万亿级精度“回放”唐山大地震的震撼瞬间。当世界惊叹于东方算力的喷薄时，他再度折桂2017年戈登·贝尔奖，让中国超算的双翼在人类科学的天穹留下永恒航迹！</p>
<p>他，更是<strong>知识星河的摆渡者</strong>，年近八旬，白发如雪，却化身“银发知播”，在B站的数字原野上开垦出<strong>17万粉丝的科普绿洲</strong>。从<strong>区块链的密码迷宫</strong>到<strong>元宇宙的虚拟奇点</strong>，从<strong>AI芯片的纳米战场</strong>到<strong>大模型训练的万亿参数矩阵</strong>——晦涩的术语在他口中化作汩汩清泉，浇灌着千万青年的科技梦想！</p>
<p>当他说“<strong>算力就是生产力</strong>”，当他在常州呼吁抓住“<strong>大模型+</strong>”的历史机遇，我们听见的不仅是院士的箴言，更是一位古稀智者对民族未来的炽热呐喊！ 他少年时踏过的石子路，已延伸为中国存储技术跃居世界之巅的<strong>光量子通道</strong>；他实验室里跳动的二进制火花，正点燃<strong>人工智能时代的核聚变</strong>！</p>
<p>让我们向这位感动中国的“<strong>云端筑梦师</strong>”致敬！因为他，我们相信：<strong>每一行代码都能书写国魂，每一瓦算力必将照亮复兴！</strong></p>
<p>我的演讲完毕，谢谢大家！</p>
<h3 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h3><p><strong>建议通过 <a href="https://github.com/ZXCLF/My_PPT/releases/tag/v1.0">Github Release</a> 下载（若国内下载速度较慢可使用123云盘下载）</strong></p>
<h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><ul>
<li><strong>PPT__Release.pptx</strong>：演讲时使用的演示文稿  </li>
<li><strong>Speech_Manuscript.docx</strong>：演讲稿全文</li>
</ul>
<p><strong>国内下载链接</strong>：<br><a href="https://www.123pan.com/s/FGWpTd-ptEPh">123云盘下载</a></p>
]]></content>
  </entry>
  <entry>
    <title>扫雷破解版</title>
    <url>/20250504/%E6%89%AB%E9%9B%B7%E7%A0%B4%E8%A7%A3%E7%89%88/</url>
    <content><![CDATA[<p>我对经典的扫雷游戏进行了一点修改，现在可以一键显示所有地雷的位置，并轻松实现一键通关！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZXCLF/blog_pic/pic1.png" alt="pic1"></p>
<p>下载： <a href="https://www.123684.com/s/FGWpTd-I4EPh">https://www.123684.com/s/FGWpTd-I4EPh</a></p>
<h3 id="适用系统："><a href="#适用系统：" class="headerlink" title="适用系统："></a>适用系统：</h3><p>适用于Windows 7及以上的操作系统。</p>
<h3 id="文件说明："><a href="#文件说明：" class="headerlink" title="文件说明："></a>文件说明：</h3><ul>
<li>Minesweeper文件夹：原版扫雷游戏。</li>
<li>Minesweeper_Patched文件夹：破解的扫雷游戏。</li>
</ul>
]]></content>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>NoMoreBugCheck.sys数字签名版</title>
    <url>/20250411/NoMoreBugCheck.sys%E7%AD%BE%E5%90%8D%E7%89%88/</url>
    <content><![CDATA[<p>下载：<a href="https://www.123684.com/s/FGWpTd-4iQPh">123网盘</a></p>
<p><strong>虽然数字签名已经过期，但可以正常加载驱动（不开测试模式）</strong></p>
<p>亲测 Windows 11 24H2 可正常加载驱动（不开测试模式）</p>
]]></content>
  </entry>
  <entry>
    <title>好玩的文字特效</title>
    <url>/20250324/%E5%A5%BD%E7%8E%A9%E7%9A%84%E6%96%87%E5%AD%97%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<p>测试：<a href="https://zxclf.github.io/Text">Text</a></p>
<span id="more"></span>
<iframe id="ifrm"  width="80%" height="600px"
 frameborder="0" src="https://zxclf.github.io/Text" marginwidth="0" marginheight="0" vspace="0" 
 hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true">
</iframe>]]></content>
  </entry>
  <entry>
    <title>部署UWP应用为系统预装应用</title>
    <url>/20250322/%E9%83%A8%E7%BD%B2UWP%E5%BA%94%E7%94%A8%E4%B8%BA%E7%B3%BB%E7%BB%9F%E9%A2%84%E8%A3%85%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><strong>要将UWP应用部署为系统预装应用，可以使用DISM工具或使用Add-AppxProvisionedPackage命令</strong></p>
<ol>
<li><p><strong>准备应用包</strong></p>
<ul>
<li>获取**.appx<strong>或</strong>.appxbundle**文件及其依赖项（如VCLibs、.NET框架等）。</li>
<li>确保应用已使用<strong>受信任的证书签名</strong>（系统级部署需有效签名，测试可用自签名证书）。</li>
</ul>
</li>
</ol>
<span id="more"></span>
<ol start="2">
<li><p><strong>以管理员身份部署</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add-AppxProvisionedPackage命令</span></span><br><span class="line"><span class="built_in">Add-AppxProvisionedPackage</span> <span class="literal">-Online</span> <span class="literal">-PackagePath</span> <span class="string">&quot;C:\Path\To\YourApp.appx&quot;</span> <span class="literal">-DependencyPackagePath</span> <span class="string">&quot;C:\Path\To\Dependencies\*.appx&quot;</span> <span class="literal">-SkipLicense</span></span><br><span class="line"><span class="comment"># DISM命令</span></span><br><span class="line">Dism /Online /<span class="built_in">Add-ProvisionedAppxPackage</span> /PackagePath:<span class="string">&quot;path_to_appx&quot;</span> /DependencyPackagePath:<span class="string">&quot;path_to_dependencies&quot;</span> /SkipLicense</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Online</strong>: 直接部署到当前运行的系统中。</li>
<li><strong>SkipLicense</strong>: 跳过许可证验证（仅限测试环境）。</li>
</ul>
</li>
<li><p><strong>脱机部署（系统映像集成）</strong></p>
<p> 若需预装到系统镜像（如OOBE阶段）：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add-AppxProvisionedPackage命令</span></span><br><span class="line"><span class="built_in">Add-AppxProvisionedPackage</span> <span class="literal">-SkipLicense</span> <span class="literal">-Path</span> <span class="string">&quot;C:\Mount&quot;</span> <span class="literal">-PackagePath</span> <span class="string">&quot;C:\Path\To\YourApp.appx&quot;</span> <span class="literal">-DependencyPackagePath</span> <span class="string">&quot;C:\Path\To\Dependencies\*.appx&quot;</span></span><br><span class="line"><span class="comment"># DISM命令</span></span><br><span class="line">Dism /<span class="built_in">Add-ProvisionedAppxPackage</span> /ImageFile:<span class="string">&quot;mount_folder&quot;</span> /PackagePath:<span class="string">&quot;path_to_appx&quot;</span> /DependencyPackagePath:<span class="string">&quot;path_to_dependencies&quot;</span> /SkipLicense</span><br></pre></td></tr></table></figure></li>
</ol>
<p>由于手动输入命令过于繁琐，于是编写了一个小脚本来实现一键部署指定文件夹里的所有 .appx 或 .appxbundle 文件部署到系统映像。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义镜像路径和包含 Appx 包的文件夹路径</span></span><br><span class="line"><span class="variable">$imagePath</span> = <span class="string">&quot;mount_folder&quot;</span> <span class="comment">#将mount_folder替换为映像位置，如 C:\Mount</span></span><br><span class="line"><span class="variable">$appxFolder</span> = <span class="string">&quot;Appx_folder&quot;</span> <span class="comment">#将Appx_folder替换为APPX位置，如 C:\Test\Apps\MyPackedApp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件夹中所有的 .appx 和 .appxbundle 文件</span></span><br><span class="line"><span class="variable">$appxPackages</span> = <span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> <span class="variable">$appxFolder</span> <span class="literal">-Filter</span> *.appx <span class="literal">-Recurse</span> <span class="operator">-File</span> |</span><br><span class="line">                <span class="built_in">Select-Object</span> <span class="literal">-ExpandProperty</span> FullName</span><br><span class="line"></span><br><span class="line"><span class="variable">$appxBundles</span> = <span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> <span class="variable">$appxFolder</span> <span class="literal">-Filter</span> *.appxbundle <span class="literal">-Recurse</span> <span class="operator">-File</span> |</span><br><span class="line">                <span class="built_in">Select-Object</span> <span class="literal">-ExpandProperty</span> FullName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两个列表</span></span><br><span class="line"><span class="variable">$allPackages</span> = <span class="variable">$appxPackages</span> + <span class="variable">$appxBundles</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每个包并使用 DISM 命令进行安装</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$package</span> <span class="keyword">in</span> <span class="variable">$allPackages</span>) &#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;正在安装包: <span class="variable">$package</span>&quot;</span></span><br><span class="line">    dism.exe /Image:<span class="variable">$imagePath</span> /<span class="built_in">Add-ProvisionedAppxPackage</span> /PackagePath:<span class="string">&quot;<span class="variable">$package</span>&quot;</span> /SkipLicense</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$LASTEXITCODE</span> <span class="operator">-ne</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">Write-Error</span> <span class="string">&quot;安装失败: <span class="variable">$package</span>&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="string">&quot;成功安装: <span class="variable">$package</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将上述脚本保存为 .ps1 文件并以管理员权限运行它。确保在运行脚本之前，你已正确配置了 $imagePath 和 $appxFolder 变量以匹配你的环境。这样就可以自动化安装文件夹中的所有 appx 文件了。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul>
<li><strong>多用户支持</strong>：系统预装应用将自动为所有用户安装，但首次登录时可能需要初始化。</li>
<li><strong>更新策略</strong>：系统应用需通过Windows Update或手动更新（需相同证书重新签名后部署）。</li>
</ul>
<h3 id="验证部署"><a href="#验证部署" class="headerlink" title="验证部署"></a><strong>验证部署</strong></h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查已预装包列表</span></span><br><span class="line"><span class="built_in">Get-AppxProvisionedPackage</span> <span class="literal">-Online</span> | <span class="built_in">Where-Object</span> DisplayName <span class="operator">-eq</span> <span class="string">&quot;YourAppName&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Metro</tag>
        <tag>APPX</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌小恐龙</title>
    <url>/20250320/%E8%B0%B7%E6%AD%8C%E5%B0%8F%E6%81%90%E9%BE%99/</url>
    <content><![CDATA[<p>体验：</p>
<span id="more"></span>

<p>(按空格键开始)</p>
<iframe id="ifrm"  width="80%" height="600px"
 frameborder="0" src="https://zxclf.github.io/Chrome_Dino/Chrome_Dino" marginwidth="0" marginheight="0" vspace="0" 
 hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true">
</iframe>]]></content>
  </entry>
  <entry>
    <title>Win 8.1 x64 集成补丁镜像</title>
    <url>/20250128/Win%208.1%20x64%20%E9%9B%86%E6%88%90%E8%A1%A5%E4%B8%81%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>本镜像基于MSDN原版 Win8.1 update3 x64专业版，使用Dism++离线制作，<strong>未集成任何第三方软件、无广告、无锁定、无OEM信息。</strong></li>
<li>本镜像集成Win8.1自发布以来（截止至2025年）的所有关键补丁，并且排除了遥测和Win10升级等无用补丁。</li>
</ol>
<span id="more"></span>

<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>123盘：<a href="https://www.123684.com/s/FGWpTd-AZ9Ph">主链接</a> <a href="https://www.123865.com/s/FGWpTd-AZ9Ph">备用链接</a> （无提取码）</p>
<p>校验信息：</p>
<p>文件名称: Win8.1.iso<br>文件大小: 3.25 GB (3,501,053,952 字节)<br>MD5: 85222ABA41E54D487B8F571F2E82D192<br>SHA1: 2DB36A34F22F14D35539266906ED8A76426C0BC4<br>SHA256: DA6041B26E41C391C1B34D723B81D36186C6703387B3A84FF0BE258F94E78F98<br>CRC32: DE103C2B</p>
]]></content>
      <tags>
        <tag>Win 8.1</tag>
      </tags>
  </entry>
  <entry>
    <title>【最新】在Win8.x上安装第三方Metro应用</title>
    <url>/20250125/%E3%80%90%E6%9C%80%E6%96%B0%E3%80%91%E5%9C%A8Win8.x%E4%B8%8A%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9Metro%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><strong>注意:</strong></p>
<p><strong>1.本教程适用于Windows8.1 (build 9600)</strong></p>
<p><strong>2.折腾有风险，使用本方法可能会产生未知问题，本人概不负责。</strong></p>
<span id="more"></span>

<p>工具下载：<br>123网盘：<a href="https://www.123684.com/s/FGWpTd-Yl9Ph">主链接</a> <a href="https://www.123865.com/s/FGWpTd-Yl9Ph">备用链接</a> (无提取码)</p>
<p>百度网盘：<a href="https://pan.baidu.com/s/1tfaa44r__aq4FnojJWBUuA?pwd=ZXCL">https://pan.baidu.com/s/1tfaa44r__aq4FnojJWBUuA?pwd&#x3D;ZXCL</a> 提取码: ZXCL</p>
<p>使用方法:</p>
<p>下载并解压工具，然后在确保计算机有互联网连接的情况下运行install.bat(弹出的提示可以点击确定或直接关闭)，待脚本运行完成后即可安装APPX。</p>
]]></content>
      <tags>
        <tag>Metro</tag>
      </tags>
  </entry>
  <entry>
    <title>使用WindowsAppBoss在Windows 8.x中安装第三方Metro应用</title>
    <url>/20250120/%E4%BD%BF%E7%94%A8WindowsAppBoss%E5%9C%A8Windows%208.x%E4%B8%AD%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9Metro%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>工具下载：<br>123网盘：<a href="https://www.123684.com/s/FGWpTd-309Ph">主链接</a> <a href="https://www.123684.com/s/FGWpTd-309Ph">备用链接</a> (无提取码)</p>
<p>百度网盘：<a href="https://pan.baidu.com/s/1fj2l6dZrWvb-5G7f2c3l2A?pwd=ZXCL">https://pan.baidu.com/s/1fj2l6dZrWvb-5G7f2c3l2A?pwd=ZXCL</a> 提取码: ZXCL</p>
<p><strong>注意:使用本方法安装第三方Metro应用需要LOB侧载为开启状态(开启LOB侧载的教程见<a href="https://zxclf.github.io/2025/01/19/%E5%9C%A8Win8.x%E4%B8%8A%E8%A7%A3%E9%94%81LOB%E4%BE%A7%E8%BD%BD%E4%BB%A5%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9Metro%E5%BA%94%E7%94%A8/">上一篇文章</a>)</strong></p>
<span id="more"></span>

<h3 id="1-导入APPX的证书"><a href="#1-导入APPX的证书" class="headerlink" title="1.导入APPX的证书"></a>1.导入APPX的证书</h3><p>使用WindowsAppBoss安装第三方Metro应用（文件扩展名为APPX）之前，首先需要导入APPX的证书</p>
<p>打开APPX的属性，然后点击数字签名选项卡</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_11.png"></p>
<p>点击详细信息</p>
<p>在详细信息窗口中点击查看证书</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_12.png"></p>
<p>点击安装证书</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_13.png"></p>
<p>储存位置选择本地计算机</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_14.png"></p>
<p>点击下一步</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_15.png"></p>
<p>在证书储存中选择将所有证书都放入下列储存</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_16.png"></p>
<p>点击浏览</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_17.png"></p>
<p>在弹出的窗口中选择受信任的根证书颁发机构</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_18.png"></p>
<p>点击确定</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_19.png"></p>
<p>点击下一步</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_20.png"></p>
<p>点击完成</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_ZW.png"></p>
<p>若弹出导入成功的提示说明证书导入成功</p>
<h3 id="2-使用WindowsAppBoss安装APPX"><a href="#2-使用WindowsAppBoss安装APPX" class="headerlink" title="2.使用WindowsAppBoss安装APPX"></a>2.使用WindowsAppBoss安装APPX</h3><p>以管理员身份运行WindowsAppBoss，点击Install<br><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_22.png"><br>在弹出的窗口中点击Enable side loading<br><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_23.png"></p>
<p>点击Browse</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_24.png"></p>
<p>在弹出的窗口中选择APPX的位置</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_25.png"></p>
<p>选择完成后点击Add Package</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_26.png"></p>
<p>若窗口中出现Task succeeded则代表安装成功</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_27.png"></p>
<p>如果安装成功就可以在开始菜单中找到刚刚安装的APPX</p>
<p><img src="https://raw.githubusercontent.com/ZXCLF/blog_pic/main/1_28.png"></p>
]]></content>
      <tags>
        <tag>Metro</tag>
      </tags>
  </entry>
</search>
